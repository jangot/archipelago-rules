import { Injectable, Logger } from '@nestjs/common';
import { IDataService } from '../data/idata.service';
import { UserCreateRequestDto, UserResponseDto, UserUpdateRequestDto } from '../dto';
import { EntityMapper } from '@library/entity/mapping/entity.mapper';
import { DtoMapper } from '@library/entity/mapping/dto.mapper';
import { SearchQueryDto } from '@library/shared/common/search';
import { createPaginationWrapper, PagingDto } from '@library/shared/common/paging';
import { ContactType } from '@library/entity/enum';
import { UserDetailResponseDTO } from '../dto/response/user-detail-response.dto';
import { MapToDto } from '@library/entity/mapping/maptodto.decorator';
import { ApplicationUser } from '../domain/entities';

@Injectable()
export class UsersService {
  // Creating a Logger like this sets the Context, which will log the class name with the Log entries
  private readonly logger: Logger = new Logger(UsersService.name);

  constructor(private readonly dataService: IDataService) {}

  @MapToDto(UserDetailResponseDTO)
  public async getUserDetailById(userId: string): Promise<UserDetailResponseDTO | null> {
    const result = await this.dataService.users.getUserDetailById(userId);

    // Custom decorator will do this work automatically.
    //const dtoResult = DtoMapper.toDto(result, UserDetailResponseDTO);

    // Tell the Typescript compiler to trust us here, the @MapToDto() decorator is doing the DtoMapper.toDto() work automatically
    return result as unknown as UserDetailResponseDTO | null;
  }

  // I don't want the Service classes to throw Exceptions if a User isn't found.
  // I would prefer to have the Controller or any other consumer determine if not finding
  // a User is an error or not.
  // If a real exception happens, then let it bubble up
  // We should create a Top level Exception handler that shows different information
  // depending on the environment (dev, prod, etc)
  // We would also want to Log these Errors (but only 'real' errors should be logged as errors)
  @MapToDto(UserResponseDto)
  public async getUserById(id: string): Promise<UserResponseDto | null> {
    this.logger.debug(`getUserById: Getting User by Id: ${id}`);

    const result = await this.dataService.users.getById(id);

    // Tell the Typescript compiler to trust us here, the @MapToDto() decorator is doing the DtoMapper.toDto() work automatically
    return result as unknown as UserResponseDto | null;
  }

  /**
   * Retrieves a user by their contact information, which can be either an email or a phone number.
   *
   * @param {string} contact - The contact information of the user (email or phone number).
   * @param {ContactType} type - The type of contact information (EMAIL or PHONE_NUMBER).
   * @returns {Promise<UserResponseDto | null>} - A promise that resolves to a UserResponseDto if a user is found, or null if no user is found.
   */
  @MapToDto(UserResponseDto)
  public async getUserByContact(contact: string, type: ContactType): Promise<UserResponseDto | null> {
    this.logger.debug(`getUserByContact: Getting User by ${type} Contact: ${contact}`);
    const user = this.dataService.users.getUserByContact(contact, type);

    // Tell the Typescript compiler to trust us here, the @MapToDto() decorator is doing the DtoMapper.toDto() work automatically
    return user as unknown as UserResponseDto | null;
  }

  @MapToDto(UserResponseDto)
  public async createUser(input: UserCreateRequestDto): Promise<UserResponseDto | null> {
    this.logger.debug(`createUser: Creating User: ${input.email}`);

    // EntityMapper.toEntity will ignore 'id' field and it is expected as it will be auto-generated by ORM
    const user = EntityMapper.toEntity(input, ApplicationUser);
    const result = await this.dataService.users.insert(user, true);

    // Tell the Typescript compiler to trust us here, the @MapToDto() decorator is doing the DtoMapper.toDto() work automatically
    return result as unknown as UserResponseDto | null;
  }

  public async updateUser(input: UserUpdateRequestDto): Promise<boolean> {
    this.logger.debug(`updateUser: Updating User: ${input.id}`);

    // TODO: Update method requires separate 'id' and 'ApplicationUser' object which already contain this
    // Also 'update' method gets 'ApplicationUser' where all fields are required, while update should support partial (up to one field) updates, isnt it?
    // So here is a point where we should decide what way we will choose:
    // - change base 'update' method to support partial updates (along with data validation)
    // - do updates in 'merge' way where each field goes through check 'is change provided or not' and then update
    // For me p.1 seems way easier and straightforward
    const user = EntityMapper.toEntity(input, ApplicationUser);
    const result = await this.dataService.users.update(user.id, user);
    return result;
  }

  public async deleteUser(id: string): Promise<boolean> {
    this.logger.debug(`deleteUser: Soft-Deleting User: ${id}`);

    // Do soft delete as many other Entities may be referenced to this one
    const result = await this.dataService.users.softDelete({ id });
    return result;
  }

  public async restoreUser(id: string): Promise<boolean> {
    this.logger.debug(`restoreUser: Restoring User: ${id}`);

    const result = await this.dataService.users.restore({ id });
    return result;
  }

  // TODO: Create Pagination custom Decorator, since there is definitely a pattern here to follow
  // and we don't want to copy and paste essentially the same 7-8 lines of code for every paginated
  // request in our services
  public async search(query: SearchQueryDto): Promise<PagingDto<UserResponseDto>> {
    this.logger.debug(`search: Searching for Users with query: ${query}`);

    const { filters, paging } = query;
    const result = await this.dataService.users.search(filters, paging);

    if (!result?.data?.length) {
      return createPaginationWrapper<UserResponseDto>({ ...paging, currentCount: 0, totalCount: 0, data: [] });
    }

    const { data, meta } = result;
    const dtoResult = data.map((r) => DtoMapper.toDto(r, UserResponseDto)).filter((dto) => dto !== null);
    // Whats actually current count stands for? limit+skip?
    return createPaginationWrapper<UserResponseDto>({ ...meta, currentCount: meta.limit, data: dtoResult });
  }

  /**
   * Checks if a user with the given email or phone number already exists.
   *
   * @param {string} email - The email of the user to check.
   * @param {string} phoneNumber - The phone number of the user to check.
   * @returns {Promise<boolean>} - A promise that resolves to true if the user is new (does not exist), or false if the user already exists.
   */
  public async isNewUser(email: string, phoneNumber: string): Promise<boolean> {
    const [userByEmail, userByPhone] = await Promise.all([
      this.getUserByContact(email, ContactType.EMAIL),
      this.getUserByContact(phoneNumber, ContactType.PHONE_NUMBER),
    ]);

    return !userByEmail && !userByPhone;
  }
}
