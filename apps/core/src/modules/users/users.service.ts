import { IDomainServices } from '@core/modules/domain/idomain.services';
import { ContactType } from '@library/entity/enum';
import { DtoMapper } from '@library/entity/mapping/dto.mapper';
import { EntityMapper } from '@library/entity/mapping/entity.mapper';
import { EntityFailedToUpdateException, EntityNotFoundException } from '@library/shared/common/exception/domain';
import { createPaginationWrapper, PagingDto } from '@library/shared/common/paging';
import { SearchQueryDto } from '@library/shared/common/search';
import { ApplicationUser } from '@library/shared/domain/entity';
import { Injectable, Logger } from '@nestjs/common';
import { UserCreateRequestDto, UserUpdateRequestDto } from './dto/request';
import { UserDetailResponseDto, UserDetailsUpdateResponseDto, UserResponseDto } from './dto/response';

@Injectable()
export class UsersService {
  // Creating a Logger like this sets the Context, which will log the class name with the Log entries
  private readonly logger: Logger = new Logger(UsersService.name);

  constructor(private readonly domainServices: IDomainServices) {}

  public async getUserDetailById(userId: string): Promise<UserDetailResponseDto | null> {
    const result = await this.domainServices.userServices.getUserById(userId);

    return DtoMapper.toDto(result, UserDetailResponseDto);
  }

  // I don't want the Service classes to throw Exceptions if a User isn't found.
  // I would prefer to have the Controller or any other consumer determine if not finding
  // a User is an error or not.
  // If a real exception happens, then let it bubble up
  // We should create a Top level Exception handler that shows different information
  // depending on the environment (dev, prod, etc)
  // We would also want to Log these Errors (but only 'real' errors should be logged as errors)
  public async getUserById(id: string): Promise<UserResponseDto | null> {
    this.logger.debug(`getUserById: Getting User by Id: ${id}`);

    const result = await this.domainServices.userServices.getUserById(id);

    return DtoMapper.toDto(result, UserResponseDto);
  }

  /**
   * Retrieves a user by their contact information, which can be either an email or a phone number.
   *
   * @param {string} contact - The contact information of the user (email or phone number).
   * @param {ContactType} type - The type of contact information (EMAIL or PHONE_NUMBER).
   * @returns {Promise<UserResponseDto | null>} - A promise that resolves to a UserResponseDto if a user is found, or null if no user is found.
   */
  public async getUserByContact(contact: string, type: ContactType): Promise<UserResponseDto | null> {
    this.logger.debug(`getUserByContact: Getting User by ${type} Contact: ${contact}`);
    const user = await this.domainServices.userServices.getUserByContact(contact, type);

    return DtoMapper.toDto(user, UserResponseDto);
  }

  public async createUser(input: UserCreateRequestDto): Promise<UserResponseDto | null> {
    this.logger.debug(`createUser: Creating User: ${input.email}`);

    // EntityMapper.toEntity will ignore 'id' field and it is expected as it will be auto-generated by ORM
    const user = EntityMapper.toEntity(input, ApplicationUser);
    const result = await this.domainServices.userServices.createNewUser(user);

    return DtoMapper.toDto(result, UserResponseDto);
  }

  /**
   * Updates User details by merging the existing user data with the provided updates.
   * This method is similar to {@link updateUser}, but it allows updating only details information 
   * without modifying critical fields like email or phone number.
   * @param userId Existing User ID to update
   * @param updates Updates to apply to the User
   * @returns Updated User details
   */
  public async updateUser(userId: string, updates: UserUpdateRequestDto): Promise<UserDetailsUpdateResponseDto | null> { 
    const user = await this.domainServices.userServices.getUserById(userId); 
    if (!user) { 
      this.logger.error(`updateDetails: User not found for ID: ${userId}`); 
      throw new EntityNotFoundException('User not found'); 
    } 
    const updatePayload = { ...user, ...updates }; 
 
    const updateResult = await this.domainServices.userServices.updateUser(updatePayload); 
 
    if (!updateResult) { 
      this.logger.error(`updateDetails: Could not apply updates for ID: ${userId}`, updatePayload); 
      throw new EntityFailedToUpdateException('Could not update the User'); 
    } 
 
    const updatedUser = await this.domainServices.userServices.getUserById(userId); 
    return DtoMapper.toDto(updatedUser, UserDetailsUpdateResponseDto); 
  } 

  public async deleteUser(id: string): Promise<boolean> {
    this.logger.debug(`deleteUser: Soft-Deleting User: ${id}`);

    // Do soft delete as many other Entities may be referenced to this one
    return this.domainServices.userServices.softDeleteUser(id);
  }

  public async restoreUser(id: string): Promise<boolean> {
    this.logger.debug(`restoreUser: Restoring User: ${id}`);

    return this.domainServices.userServices.restoreUser(id);
  }

  // TODO: Create Pagination custom Decorator, since there is definitely a pattern here to follow
  // and we don't want to copy and paste essentially the same 7-8 lines of code for every paginated
  // request in our services
  public async search(query: SearchQueryDto): Promise<PagingDto<UserResponseDto>> {
    this.logger.debug(`search: Searching for Users with query: ${query}`);

    const { filters, paging } = query;
    const result = await this.domainServices.userServices.searchUsers(filters, paging);

    if (!result?.data?.length) {
      return createPaginationWrapper<UserResponseDto>({ ...paging, currentCount: 0, totalCount: 0, data: [] });
    }

    const { data, meta } = result;
    const dtoResult = data.map((r) => DtoMapper.toDto(r, UserResponseDto)).filter((dto) => dto !== null);
    // Whats actually current count stands for? limit+skip?
    return createPaginationWrapper<UserResponseDto>({ ...meta, currentCount: meta.limit, data: dtoResult });
  }

  /**
   * Checks if a user with the given email or phone number already exists.
   *
   * @param {string} email - The email of the user to check.
   * @param {string} phoneNumber - The phone number of the user to check.
   * @returns {Promise<boolean>} - A promise that resolves to true if the user is new (does not exist), or false if the user already exists.
   */
  public async isNewUser(email: string, phoneNumber: string): Promise<boolean> {
    const [userByEmail, userByPhone] = await Promise.all([
      this.getUserByContact(email, ContactType.EMAIL),
      this.getUserByContact(phoneNumber, ContactType.PHONE_NUMBER),
    ]);

    return !userByEmail && !userByPhone;
  }
}
